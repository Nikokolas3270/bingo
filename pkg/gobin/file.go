package gobin

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/pkg/errors"
)

// VersionV1 is the version of the file format produced by this gobin version.
const VersionV1 = "v1.0.0"

// Buildable represents details of the requested buildable Go package (aka "binary").
type Buildable struct {
	module string
	// subPackage contains all requested buildable packages with this module.
	// if the root package is requested as well `.` is required to be part of subPackages.
	subPackages []string
}

func (b Buildable) Module() string { return b.module }

func (b Buildable) Packages() (s []string) {
	for _, pkg := range b.subPackages {
		s = append(s, path.Join(b.module, pkg))
	}
	return s
}

func (b Buildable) SubPackages() []string {
	return b.subPackages
}

// NewBuildable creates new Buildable.
func NewBuildable(module string, subPkgs ...string) Buildable {
	if len(subPkgs) == 0 {
		subPkgs = append(subPkgs, ".")
	}

	sort.Strings(subPkgs)
	return Buildable{
		module:      module,
		subPackages: subPkgs,
	}
}

// Parse parsers gobin Go binaries file and returns buildables. See `binariesFileTemplate` for the
// format of the file.
// Supports VersionV1 only.
func Parse(filePath string, file io.Reader) (binaries []Buildable, _ error) {
	binFileAst, err := parser.ParseFile(token.NewFileSet(), filepath.Base(filePath), file, 0)
	if err != nil {
		return nil, errors.Wrapf(err, "read %s", filePath)
	}

	for _, importSpec := range binFileAst.Imports {

	}
	// Walk traverses an AST in depth-first order: It starts by calling
	// v.Visit(node); node must not be nil. If the visitor w returned by
	// v.Visit(node) is not nil, Walk is invoked recursively with visitor
	// w for each of the non-nil children of node, followed by a call of
	// w.Visit(nil).
	ast.Walk(visitorFn(func(node ast.Node) (w ast.Visitor) {
		fmt.Printf("%T \n", node)
		return nil
	}))
	return binaries, nil
}

type visitorFn func(node ast.Node) (w ast.Visitor)

func (fn visitorFn) Visit(node ast.Node) ast.Visitor {
	return fn(node)
}

const binariesFileTemplate = `// Code generated by https://github.com/bwplotka/gobin . DO NOT EDIT.
// NOTE: Actually you can edit just fine, just don't be surprised if the file will be rewritten at some point by 
// gobin tool.
//
// This file is and extended version of somethings that is called "tools.go package" described here: https://github.com/golang/go/issues/25922#issuecomment-590529870
// It allows go modules to maintain certain version of binaries you or your project use.
// Main extension that bwplotka/gobin adds, is that the file has to be stored as the separate go module file, which allows 
// separation of dev tools from critical, production code which is th key.
//
// Read more on https://github.com/bwplotka/gobin .

// +build tools
package {{ .ModDir }}

import (
{{- range .Buildables }}
	_ "{{ .Module }}" // Binaries: {{ .SubPackages }}.
{{- end}}
)

const (
	// FileVersion represents version of this file. This will tell future versions of gobin how to parse this file.
	FileVersion = "v1.0.0"
	// Gobin version used to generate this file. Used for debugging only.
	GobinVersion = "{{ .GobinVersion }}"
)
`

// Recreate removes and creates again the gobin file with given binaries.
// Before generating given binaries are deterministically sorted and deduplicated.
func Recreate(filePath string, file io.Writer, bs []Buildable) error {
	tmpl, err := template.New(filepath.Base(filePath)).Parse(binariesFileTemplate)
	if err != nil {
		return errors.Wrap(err, "parse gobin template")
	}

	_, modDir := filepath.Split(filepath.Dir(filePath))
	modDir = strings.TrimLeft(modDir, ".")

	if modDir == "" {
		return errors.Errorf("moddir cannot be empty, got filePath: %v", filePath)
	}
	data := struct {
		GobinVersion string
		ModDir       string

		Buildables []Buildable
	}{
		GobinVersion: "??",
		ModDir:       modDir,
	}

	dedup := map[string]Buildable{}
	for _, b := range bs {
		if b.module == "" {
			return errors.Errorf("found unexpected buildable with empty module. Got: %v", bs)
		}
		existing, ok := dedup[b.module]
		if !ok {
			subPkg := make([]string, len(b.subPackages))
			copy(subPkg, b.subPackages)
			sort.Strings(subPkg)
			dedup[b.module] = NewBuildable(b.module, subPkg...)
			continue
		}

		for _, sb := range b.subPackages {
			i := sort.SearchStrings(existing.subPackages, sb)
			if i == len(existing.subPackages) {
				existing.subPackages = append(existing.subPackages, sb)
				continue
			}

			if existing.subPackages[i] == sb {
				continue
			}

			existing.subPackages = append(existing.subPackages[:i], append([]string{sb}, existing.subPackages[i:]...)...)
		}
		dedup[b.module] = existing
	}

	for _, b := range dedup {
		data.Buildables = append(data.Buildables, b)
	}
	sort.Slice(data.Buildables, func(i, j int) bool {
		return strings.Compare(data.Buildables[i].module, data.Buildables[j].module) < 0
	})
	return tmpl.Execute(file, data)
}
